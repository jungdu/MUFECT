# 2. 오디오 분석의 원리 (FFT)

소리 파일이 단순한 "숫자들의 나열"이라는 것을 알았습니다. 이제 이 숫자들에서 어떻게 "둥둥거리는 베이스"와 "날카로운 하이햇" 소리를 구분해내는지 알아봅니다.

## 1. 시간 영역 vs 주파수 영역

### 시간 영역 (Time Domain)
- **무엇인가**: 시간의 흐름에 따른 소리의 크기 변화입니다.
- **보이는 것**: 오디오 편집기에서 흔히 보는 **파형(Waveform)**입니다.
- **한계**: 여기서 "지금 저음이 얼마나 센가?"를 알기는 어렵습니다. 모든 소리가 섞여 있기 때문입니다. 마치 섞어찌개 국물을 보고 소금과 설탕 양을 구분하려는 것과 같습니다.

### 주파수 영역 (Frequency Domain)
- **무엇인가**: 순간적으로 소리를 분해해서 "저음은 이만큼, 중음은 이만큼, 고음은 이만큼" 보여주는 것입니다.
- **보이는 것**: 노래방 기기 화면 하단에서 춤추는 **막대 그래프**입니다.
- **해결**: 섞인 소리를 재료별로 분리해줍니다.

## 2. 마법의 알고리즘: FFT (Fast Fourier Transform)

시간 영역의 데이터를 주파수 영역으로 바꿔주는 수학적 마법이 바로 **FFT(고속 푸리에 변환)**입니다.

- **원리**: "모든 복잡한 소리는 단순한 사인파(Sine Wave)들의 합이다"라는 수학적 사실을 이용합니다.
- **역할**: 입력된 복잡한 소리를 분해해서 주파수 성분별로 나누어 줍니다.

## 3. 웹에서의 분석 (AnalyserNode)

우리의 프로젝트(`AudioAnalyzer.ts`)에서는 웹 브라우저가 제공하는 `Web Audio API`를 사용합니다.

1. **AudioContext**: 오디오를 처리하는 공간을 만듭니다.
2. **AnalyserNode**: 오디오가 흘러가는 길목에 설치하는 "검문소"입니다.
    - 소리가 이 노드를 지나갈 때, 우리는 실시간으로 데이터를 엿볼 수 있습니다.
    - `getByteFrequencyData()`라는 함수를 쓰면 FFT가 완료된 데이터를 꺼내줍니다.

### 주요 설정값 (Configuration)
- **fftSize**: 데이터를 얼마나 세밀하게 쪼갤지 결정합니다. 우리 코드는 `2048`을 사용합니다.
    - 결과로 나오는 데이터(막대)의 개수는 이 값의 절반인 `1024`개가 됩니다.
- **Smoothing (부드러움 처리)**: 음악은 순간적으로 너무 빠르게 변합니다. 막대 그래프가 미친 듯이 튀면 눈이 아프기 때문에, 이전 프레임의 데이터와 살짝 섞어서 부드럽게 움직이게 만듭니다. (`0.8` 정도 사용)
